* Introduction :TODO:

This configuration is totaly comprised inside this org file using the org-babel tangle funcitonality.

When first cloning this repo you'll need to tangle the files yourselves using <keymap> to instantiate the config. After that, you'll be able to browse around the config code.

** Navigation :TODO:

Navigating through this file is done through the following keybinds:
<keybind list>

There is also a custom minor mode =config-mode= (adapted from [[github:rougier/dotemacs][rougier]]) which implements a sidebar that acts as an outline for better navigation. This becomes available after the config has been tangled and Emacs restarted.

* Setup

** Early Init
:PROPERTIES:
:header-args:emacs-lisp: :tangle "early-init.el" :eval no
:END:

This tangles to the [[file:early-init.el][early-init.el]]  file. It will be loaded /before/ emacs reaches the init stage and takes care of some optimizations.

#+BEGIN_SRC emacs-lisp
;; early-init.el -*- lexical-binding: t; -*-

(setq
 site-run-file nil                         ; No site-wide run-time initializations.
 inhibit-default-init t                    ; No site-wide default library
 gc-cons-threshold most-positive-fixnum    ; Very large threshold for garbage
                                           ; collector during init
 package-enable-at-startup nil)            ; We'll use straight.el

(setq native-comp-eln-load-path
      (list (expand-file-name "eln-cache" user-emacs-directory)))

;; Reset garbage collector limit after init process has ended (8Mo)
(add-hook 'after-init-hook
          #'(lambda () (setq gc-cons-threshold (* 8 1024 1024))))
#+END_SRC

** Package Management
:PROPERTIES:
:header-args:emacs-lisp: :tangle "init.el" :eval no
:END:

*Nexus* uses =straight.el= for package management. We also disable auto checking for improved performance.

This section will be tangled into [[file:init.el][init.el]]

#+BEGIN_SRC emacs-lisp
;; init.el -*- lexical-binding: t; -*-

;; disables checking for speed
(setq straight-check-for-modifications nil)

;; bootstraps straight.el
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name
        "straight/repos/straight.el/bootstrap.el"
        (or (bound-and-true-p straight-base-dir)
            user-emacs-directory)))
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

;; installs use-package
(straight-use-package 'use-package)

;; makes use-package enable straight by default
(setq straight-use-package-by-default t)

#+END_SRC

We also need to load in the paths for package configuration and themes

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path
             (expand-file-name "lisp" user-emacs-directory))
(add-to-list 'custom-theme-load-path
             (expand-file-name "theme" user-emacs-directory))

#+END_SRC

All thats left is to then require the differet sections

#+begin_src emacs-lisp
(require 'core)
(require 'packages)
#+end_src

And create these paths (if they don't exist)

#+BEGIN_SRC emacs-lisp :tangle no :eval yes :results none
(make-directory (expand-file-name "lisp" user-emacs-directory) t)
(make-directory (expand-file-name "theme" user-emacs-directory) t)
#+END_SRC

** Package Loading :TODO:
:PROPERTIES:
:header-args:emacs-lisp: :tangle "lisp/packages.el" :eval no
:END:

Packages are typically grouped together in /"modules"/. These modules will need loaded in through a central file, [[file:lisp/packages.el][lisp/packages.el]].

Each one of the modules can also be conditionally loaded from here, if desired.

#+BEGIN_SRC emacs-lisp
;;; lisp/packages.el -*- lexical-binding: t; -*-

;; add lisp/packages directory to load path
(add-to-list 'load-path (expand-file-name "packages" (file-name-directory load-file-name)))

;; load modules
(require 'evil-module)

#+END_SRC

Finally, we can provide the file to ensure it is loadable from within [[file:init.el][init.el]]

#+begin_src emacs-lisp
(provide 'packages)
#+end_src

We will also need to create the =lisp/packages= directory

#+BEGIN_SRC emacs-lisp :tangle no :eval yes :results none
(make-directory (expand-file-name "lisp/packages" user-emacs-directory) t)
#+END_SRC

* Core
:PROPERTIES:
:header-args:emacs-lisp: :tangle "lisp/core.el" :eval no
:END:

** Startup

We disable almost everything from the emacs startup, keeping only the scratch buffer.

#+begin_src emacs-lisp
;;; lisp/core.el -*- lexical-binding: t; -*-

(setq-default
 inhibit-startup-screen t               ; Disable start-up screen
 inhibit-startup-message t              ; Disable startup message
 inhibit-startup-echo-area-message t    ; Disable initial echo message
 initial-scratch-message ""             ; Empty the initial *scratch* buffer
 initial-buffer-choice t)               ; Open *scratch* buffer at init

#+end_src

** Encoding

We tell emacs to use UTF-8 encoding as much as possible

#+begin_src emacs-lisp
(set-default-coding-systems 'utf-8)     ; Default to utf-8 encoding
(prefer-coding-system       'utf-8)     ; Add utf-8 at the front for automatic detection.
(set-terminal-coding-system 'utf-8)     ; Set coding system of terminal output
(set-keyboard-coding-system 'utf-8)     ; Set coding system for keyboard input on TERMINAL
(set-language-environment "English")    ; Set up multilingual environment

#+end_src

** Recovery

Here we configure the auto-save functionality, used to recover files in the event of a crash. If needed, this can be done using =M-x recover-session=.

#+begin_src emacs-lisp
(setq auto-save-list-file-prefix ; Prefix for generating auto-save-list-file-name
      (expand-file-name ".auto-save-list/.saves-" user-emacs-directory)
      auto-save-default t        ; Auto-save every buffer that visits a file
      auto-save-timeout 20       ; Number of seconds between auto-save
      auto-save-interval 200)    ; Number of keystrokes between auto-saves

#+end_src

** Backups

When editing a file for the first time, emacs will create a backup file before the first save, as to preserve the original file. This can be further configured here

#+begin_src emacs-lisp
(setq backup-directory-alist       ; File name patterns and backup directory names.
      `(("." . ,(expand-file-name "backups" user-emacs-directory)))
      make-backup-files t          ; Backup of a file the first time it is saved.
      vc-make-backup-files t       ; No backup of files under version control
      backup-by-copying t          ; Don't clobber symlinks
      version-control t            ; Version numbers for backup files
      delete-old-versions t        ; Delete excess backup files silently
      kept-old-versions 6          ; Number of old versions to keep
      kept-new-versions 9          ; Number of new versions to keep
      delete-by-moving-to-trash t) ; Delete files to trash

#+end_src

** Bookmarks

Simply set the default directory for bookmarks

#+begin_src emacs-lisp
(setq bookmark-default-file (expand-file-name "bookmark" user-emacs-directory))

#+end_src

** History

We remove text properties for kill-ring entries in order to save time and memory when loading it(see [[https:emacs.stackexchange.com/questions/4187/strip-text-properties-in-savehist][here]]).

#+begin_src emacs-lisp
(defun unpropertize-kill-ring ()
  (setq kill-ring (mapcar 'substring-no-properties kill-ring)))

(add-hook 'kill-emacs-hook 'unpropertize-kill-ring)

#+end_src

Then, we save every history available

#+begin_src emacs-lisp
(require 'savehist)

(setq kill-ring-max 50
      history-length 50)

(setq savehist-additional-variables
      '(kill-ring
        command-history
        set-variable-value-history
        custom-variable-history
        query-replace-history
        read-expression-history
        minibuffer-history
        read-char-history
        face-name-history
        bookmark-history
        file-name-history))

 (put 'minibuffer-history         'history-length 50)
 (put 'file-name-history          'history-length 50)
 (put 'set-variable-value-history 'history-length 25)
 (put 'custom-variable-history    'history-length 25)
 (put 'query-replace-history      'history-length 25)
 (put 'read-expression-history    'history-length 25)
 (put 'read-char-history          'history-length 25)
 (put 'face-name-history          'history-length 25)
 (put 'bookmark-history           'history-length 25)

#+end_src

Remove any duplicates

#+begin_src emacs-lisp
(setq history-delete-duplicates t)

#+end_src

And start history mode

#+begin_src emacs-lisp
(let (message-log-max)
  (savehist-mode))

#+end_src

Finally, we need to provide the =core.el= file so it can be loaded from within [[file:init.el][init.el]].

#+begin_src emacs-lisp
(provide 'core)
#+end_src

* UI :TODO:

* Editor :TODO:

** Evil :TODO:
:PROPERTIES:
:header-args:emacs-lisp: :tangle "lisp/packages/evil-module.el" :eval no
:END:

=evil= is heavily used throughout *Nexus*. It introduces vim keybinds which are far superior to emacs defaults in my opinion.

First, we initialize the base package

#+BEGIN_SRC emacs-lisp
;;; lisp/packages/evil.el -*- lexical-binding: t; -*-

(use-package evil
  :init
  ;; set these before evil loads
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll t)
  (setq evil-undo-system 'undo-tree)
  :config
  (evil-mode 1)
  (evil-set-leader '(normal visual motion) (kbd "SPC")))

#+END_SRC

Next, we need to setup the =evil-collection= package. This is used to set vim keybinds in other packages

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :defer 0      ;; defers loading until after init (essentially lazy laoding)
  :config
  (evil-collection-init))

#+END_SRC

Finally, we need to provide the module so it can be loaded by =lisp/packages.el=

#+begin_src emacs-lisp
(provide 'evil-module)
#+end_src

** Config Mode

As mentioned earlier, this config introduces the minor mode =config-mode= to make navigating and editing much easier.

Much of this code was adapted from rougier's literate config [[github:rougier/dotemacs][dotemacs]].


** Completion
:PROPERTIES:
:header-args:emacs-lisp: :tangle "lisp/packages/completion-module.el" :eval no
:END:

Completion is a crucial part of any IDE. Its not only the information thats given, but how it is presented.

For this, *Nexus* uses a mixture of [[github:minad/corfu][corfu]] with [[github:minad/cape][cape]], and [[github:minad/vertico][vertico]] with /orderless completion/. This handles the completion backend that gets used throughout.

*** Corfu

Corfu creates the UI for processing the capf requests from cape. We configure it here.

#+begin_src emacs-lisp
;;; lisp/packages/completion-module.el -*- lexical-binding: t; -*-

(use-package corfu
  :defer t
  :config
  (setq corfu-auto t                      ;; Enable auto completion
        corfu-auto-delay 0.25             ;; Delay before prompting (after prefix)
        corfu-auto-prefix 3               ;; Num characters before prompting
        corfu-popupinfo-delay (0.1 . 0.5) ;; Delay for documentation popup
        global-corfu-modes                ;; Remove certain modes from global list
        '((not erc-mode
               circe-mode
               help-mode
               gud-mode
               vterm-mode)
          t)
        corfu-cycle t                     ;; Enable cycling for `corfu-next/previous'
        corfu-preselect 'prompt           ;; Preselect the prompt
        corfu-quit-at-boundary nil        ;; Never quit at completion boundary
        corfu-on-exact-match nil)         ;; Do not exit on exact match
  :init
  (global-corfu-mode))                    ;; launch corfu globally

#+end_src

We can also add in some icons

#+begin_src emacs-lisp
(use-package nerd-icons-corfu
  :after corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

#+end_src

Corfu also offers a package for compatibility with the terminal. We'll only need to enable this package when in the terminal, so we'll make it conditional

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (use-package corfu-terminal
    :after corfu
    :config
    ;; remove popupinfo, enable echo, enable terminal support
    (corfu-popupinfo-mode -1)
    (setq corfu-echo-delay 0.1)
    (corfu-echo-mode +1)
    (corfu-terminal-mode +1)))

#+end_src

*** Cape



*** Vertico
